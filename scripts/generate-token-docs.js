#!/usr/bin/env node
/**
 * Generate Token Reference Documentation
 * 
 * Generates comprehensive token documentation from dist/tokens.json
 * Output: docs/TOKEN_REFERENCE.md
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';

const distDir = join(process.cwd(), 'dist');
const tokensFile = join(distDir, 'tokens.json');
const outputFile = join(process.cwd(), 'docs', 'TOKEN_REFERENCE.md');

if (!existsSync(tokensFile)) {
  console.error('❌ tokens.json not found. Run: pnpm extract:tokens');
  process.exit(1);
}

const tokens = JSON.parse(readFileSync(tokensFile, 'utf-8'));

function generateMarkdown() {
  const timestamp = new Date().toISOString();
  
  let markdown = `# Token Reference

> **Auto-generated** from \`dist/tokens.json\`  
> **Last updated**: ${timestamp}  
> **Source**: \`styles/10-tokens.css\`

---

## Overview

This document provides a complete reference for all design tokens in the Neo-Analog Design System.

**Total Tokens**: ${countTokens(tokens)}

---

`;

  // Colors
  if (tokens.color) {
    markdown += generateColorSection(tokens.color);
  }

  // Typography
  if (tokens.fontFamily || tokens.fontSize || tokens.fontWeight || tokens.lineHeight) {
    markdown += generateTypographySection(tokens);
  }

  // Spacing
  if (tokens.spacing) {
    markdown += generateSpacingSection(tokens.spacing);
  }

  // Shadows
  if (tokens.shadow) {
    markdown += generateShadowSection(tokens.shadow);
  }

  // Border Radius
  if (tokens.borderRadius) {
    markdown += generateBorderRadiusSection(tokens.borderRadius);
  }

  // Other tokens
  markdown += generateOtherTokensSection(tokens);

  markdown += `
---

## Usage

### CSS Custom Properties

All tokens are available as CSS custom properties:

\`\`\`css
.my-element {
  background-color: var(--color-paper);
  color: var(--color-lux);
  padding: var(--spacing-6);
  border-radius: var(--border-radius-card);
}
\`\`\`

### JavaScript/TypeScript

\`\`\`typescript
import tokens from '@aibos/design-system/tokens';

const primaryColor = tokens.color.gold;
const spacing = tokens.spacing[6];
\`\`\`

---

**Generated by**: \`scripts/generate-token-docs.js\`  
**Source**: \`dist/tokens.json\`
`;

  return markdown;
}

function countTokens(obj, count = 0) {
  for (const key in obj) {
    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
      count = countTokens(obj[key], count);
    } else {
      count++;
    }
  }
  return count;
}

function formatTokenValue(value) {
  if (value === null || value === undefined) {
    return '-';
  }
  
  // If it's a string, return as-is
  if (typeof value === 'string') {
    return value;
  }
  
  // If it's a number or boolean, convert to string
  if (typeof value === 'number' || typeof value === 'boolean') {
    return String(value);
  }
  
  // If it's an object, try to extract meaningful value
  if (typeof value === 'object') {
    // Check if it's an array
    if (Array.isArray(value)) {
      return JSON.stringify(value);
    }
    
    // Try to find a color value (hex code or var())
    const stringified = JSON.stringify(value);
    const colorMatch = stringified.match(/#[0-9a-fA-F]{6}|var\([^)]+\)/);
    if (colorMatch) {
      return colorMatch[0];
    }
    
    // Try to find any string value in the object
    const values = Object.values(value);
    const stringValue = values.find(v => typeof v === 'string' && (v.startsWith('#') || v.startsWith('var(') || v.match(/^\d+px$|^\d+rem$/)));
    if (stringValue) {
      return stringValue;
    }
    
    // If it's a simple object with one value, extract it
    const keys = Object.keys(value);
    if (keys.length === 1) {
      const nestedValue = value[keys[0]];
      if (typeof nestedValue === 'string') {
        return nestedValue;
      }
      // Recursively format nested value
      return formatTokenValue(nestedValue);
    }
    
    // Complex object - serialize it
    return JSON.stringify(value, null, 2).replace(/\n/g, ' ').substring(0, 100);
  }
  
  return String(value);
}

function generateColorSection(colors) {
  let section = `## Colors

### Base Colors

| Token | Value | Usage |
|-------|-------|-------|
`;

  const baseColors = ['void', 'paper', 'paper2', 'lux', 'luxDim', 'clay', 'gold'];
  baseColors.forEach(key => {
    if (colors[key]) {
      const value = formatTokenValue(colors[key]);
      const usage = getColorUsage(key);
      section += `| \`--color-${key}\` | \`${value}\` | ${usage} |\n`;
    }
  });

  section += `\n### Status Colors\n\n| Token | Value | Usage |\n|-------|-------|-------|\n`;

  const statusColors = ['success', 'warning', 'error', 'info'];
  statusColors.forEach(key => {
    if (colors[key]) {
      const value = formatTokenValue(colors[key]);
      const usage = getStatusColorUsage(key);
      section += `| \`--color-${key}\` | \`${value}\` | ${usage} |\n`;
    }
  });

  // Additional colors
  const otherColors = Object.keys(colors).filter(
    key => !baseColors.includes(key) && !statusColors.includes(key)
  );

  if (otherColors.length > 0) {
    section += `\n### Additional Colors\n\n| Token | Value |\n|-------|-------|\n`;
    otherColors.forEach(key => {
      const value = formatTokenValue(colors[key]);
      section += `| \`--color-${key}\` | \`${value}\` |\n`;
    });
  }

  section += '\n';
  return section;
}

function generateTypographySection(tokens) {
  let section = `## Typography

`;

  if (tokens.fontFamily) {
    section += `### Font Families\n\n| Token | Value |\n|-------|-------|\n`;
    Object.keys(tokens.fontFamily).forEach(key => {
      const value = formatTokenValue(tokens.fontFamily[key]);
      section += `| \`--font-family-${key}\` | \`${value}\` |\n`;
    });
    section += '\n';
  }

  if (tokens.fontSize) {
    section += `### Font Sizes\n\n| Token | Value |\n|-------|-------|\n`;
    Object.keys(tokens.fontSize).forEach(key => {
      const value = formatTokenValue(tokens.fontSize[key]);
      section += `| \`--font-size-${key}\` | \`${value}\` |\n`;
    });
    section += '\n';
  }

  if (tokens.fontWeight) {
    section += `### Font Weights\n\n| Token | Value |\n|-------|-------|\n`;
    Object.keys(tokens.fontWeight).forEach(key => {
      const value = formatTokenValue(tokens.fontWeight[key]);
      section += `| \`--font-weight-${key}\` | \`${value}\` |\n`;
    });
    section += '\n';
  }

  if (tokens.lineHeight) {
    section += `### Line Heights\n\n| Token | Value |\n|-------|-------|\n`;
    Object.keys(tokens.lineHeight).forEach(key => {
      const value = formatTokenValue(tokens.lineHeight[key]);
      section += `| \`--line-height-${key}\` | \`${value}\` |\n`;
    });
    section += '\n';
  }

  return section;
}

function generateSpacingSection(spacing) {
  let section = `## Spacing

| Token | Value | Usage |
|-------|-------|-------|
`;

  const spacingKeys = Object.keys(spacing).sort((a, b) => {
    const numA = parseInt(a) || 0;
    const numB = parseInt(b) || 0;
    return numA - numB;
  });

  spacingKeys.forEach(key => {
    const value = formatTokenValue(spacing[key]);
    section += `| \`--spacing-${key}\` | \`${value}\` | Standard spacing unit |\n`;
  });

  section += '\n';
  return section;
}

function generateShadowSection(shadow) {
  let section = `## Shadows

| Token | Value | Usage |
|-------|-------|-------|
`;

  Object.keys(shadow).forEach(key => {
    const value = formatTokenValue(shadow[key]);
    section += `| \`--shadow-${key}\` | \`${value}\` | Shadow effect |\n`;
  });

  section += '\n';
  return section;
}

function generateBorderRadiusSection(borderRadius) {
  let section = `## Border Radius

| Token | Value | Usage |
|-------|-------|-------|
`;

  Object.keys(borderRadius).forEach(key => {
    const value = formatTokenValue(borderRadius[key]);
    const usage = getBorderRadiusUsage(key);
    section += `| \`--border-radius-${key}\` | \`${value}\` | ${usage} |\n`;
  });

  section += '\n';
  return section;
}

function generateOtherTokensSection(tokens) {
  const knownSections = ['color', 'fontFamily', 'fontSize', 'fontWeight', 'lineHeight', 'spacing', 'shadow', 'borderRadius'];
  const otherKeys = Object.keys(tokens).filter(key => !knownSections.includes(key));

  if (otherKeys.length === 0) return '';

  let section = `## Other Tokens\n\n`;

  otherKeys.forEach(key => {
    if (typeof tokens[key] === 'object' && tokens[key] !== null) {
      section += `### ${key.charAt(0).toUpperCase() + key.slice(1)}\n\n| Token | Value |\n|-------|-------|\n`;
      Object.keys(tokens[key]).forEach(subKey => {
        const value = formatTokenValue(tokens[key][subKey]);
        section += `| \`--${key}-${subKey}\` | \`${value}\` |\n`;
      });
      section += '\n';
    }
  });

  return section;
}

function getColorUsage(key) {
  const usages = {
    void: 'Main background (dark theme)',
    paper: 'Panel/card background',
    paper2: 'Hover state, input background',
    lux: 'Primary text color',
    luxDim: 'Secondary text color',
    clay: 'Metadata, labels',
    gold: 'Primary accent color',
  };
  return usages[key] || 'Color token';
}

function getStatusColorUsage(key) {
  const usages = {
    success: 'Success states, positive actions',
    warning: 'Warning states, attention needed',
    error: 'Error states, destructive actions',
    info: 'Info states, neutral information',
  };
  return usages[key] || 'Status color';
}

function getBorderRadiusUsage(key) {
  const usages = {
    card: 'Card components',
    panel: 'Panel components',
    button: 'Button components',
    input: 'Input components',
    small: 'Small elements',
    large: 'Large elements',
  };
  return usages[key] || 'Border radius';
}

// Generate and write
try {
  const markdown = generateMarkdown();
  writeFileSync(outputFile, markdown, 'utf-8');
  console.log('✅ Token reference generated: docs/TOKEN_REFERENCE.md');
} catch (error) {
  console.error('❌ Error generating token docs:', error.message);
  process.exit(1);
}

